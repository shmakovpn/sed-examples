Самая простая программа на **sed**
==================================

 .. epigraph::

  Простота - хуже воровства

Давайте создадим текстовый файл из десяти уникальных строк.

.. code-block:: text

 one
 two
 three
 four
 five
 six
 seven
 eight
 nine
 ten

Назовем его *one-ten.txt*. Он нам понадобиться в дальнейшем для разного рода
экспериментов.

А теперь напишем свою первую программу:

.. code-block:: bash

 cat one-ten.txt | sed -re ''

Будет выведено десять уникальных строк на консоль. Как если бы простро выполнить
команду **cat**, вообще без **sed**.

Давайте посмотрим на ключи:
 | r использовать регулярные выражения в теле программы
 | e код программы, в нашем случае \'\'

Все очень просто, выполнить код после **e** и если в нем есть регулярные выражения,
то выполнить и их.

Почему, же мы получили десять уникальных строк? Потому, что **sed** считывает
стандартный ввод построчно в буфер "pattern space",
далее выполняя код своей программы (ничего) к каждой из строк.
По умолчанию, в конце обработки каждой итерации, **sed** выполняет команду **p**.
Что означает печать содержимого "pattern space". Используя ключ **n**, можно
отключить такой режим.

Таким образом наша первая программа на **sed** не является самой простой.
Хотя и является самой короткой. Запишем ее по другому.

.. code-block:: bash

 cat one-ten.txt | sed -nre 'p'

Самая простая будет:

.. code-block:: bash

 cat one-ten.txt | sed -nre ''

Она ничего не выводит, как и ожидалось. Давайте сделаем ее аналог на **perl**.

**sed**:

    .. code-block:: bash

     cat one-ten.txt | sed -nre ''

**perl**:

    .. code-block:: bash

     cat one-ten.txt | perl -e '$hs="";$ps="";while($ps=<>){chomp($ps);}'

 или (для извращенцев):

    .. code-block:: bash

     cat one-ten.txt | perl -e 'while(<>){chomp;}'

В **sed** есть две переменные "pattern space" и "hold space".
Содержимое которых при запуске прошграмм изначально является пустым.
На **perl** это можно явно выразить как присвоение переменным *$ps*
и *$hs* пустых значений. Однако, можно этого неделать,
что не является ошибкой. Можно вместо *$ps* использовать переменную
по умолчанию *$_*, код становится еще короче и непонятнее.
Чем больше меньше кода тем незаменимее программист.
*while($ps=<>){}* цикл считывающий в *$ps* стандартный ввод.
*chomp($ps)* отрезает от *$ps* перевод строки.

Вернемся к самому первому примеру:

**sed**:

    .. code-block:: bash

     cat one-ten.txt | sed -re ''

 или

    .. code-block:: bash

     cat one-ten.txt | sed -nre 'p'

**perl**:

    .. code-block:: bash

     cat one-ten.txt | perl -e '$hs="";$ps="";while($ps=<>){chomp($ps);print($ps."\n");}'

 или (ключ *l* включает автоматическое добавление перевода строки "\\n" при вызове *print*):

    .. code-block:: bash

     cat one-ten.txt | perl -le '$hs="";$ps="";while($ps=<>){chomp($ps);print($ps);}'

 можно покороче, но не по талантлевие (на **sed** все равно короче):

    .. code-block:: bash

     cat one-ten.txt | perl -le 'while(<>){chomp; print;}'

 заменим *print* на *say*, ключ *l* в данном случае становится излишним, а *e* надо поменять на *E*:

    .. code-block:: bash

     cat one-ten.txt | perl -E 'while(<>){chomp;say;}'

 Ларри Уол, создатель **perl**, не зря говорил о более чем одном пути:

    .. code-block:: bash

     cat one-ten.txt | perl -nE 'chomp;say;'

 Добавим извращений:

    .. code-block:: bash

     cat one-ten.txt | perl -ple ''

 Чтобы объяснить последний пример,
 давайте декомпилируем создаваемую интерпритатором **perl** программу.
 Выполним следующее:

    .. code-block:: bash

     perl -MO=Deparse -ple ''

 Получим:

    .. code-block:: perl

     BEGIN { $/ = "\n"; $\ = "\n"; }  # автоматически добавлять перевод строки после print
     # цикл построчной обработки стандартного ввода
     LINE: while (defined($_ = readline ARGV)) {
         chomp $_;  # удалить перевод строки
     }
     continue {
         die "-p destination: $!\n" unless print $_;  # вывести строку на stdout
     }
     -e syntax OK

 Подведем некоторые итоги. **sed** читает вывод построчно и каждый раз сначала отезает от
 перевод строки, затем помещает строку без перевода строки
 в буфер "pattern space", далее выполняет
 код программы после *-re* или *-nre*. После выполнения программы, если нет ключа *-n*
 будет выполнена команда *p* - вывод "pattern space" плюс перевод строки на стандартный вывод.

 Вывод номер два. Одно и тоже на **perl** можно сделать по разному. Очевидно, что в качестве
 "pattern space" лучше использовать переменную *$_*. *sed -re* соответствует *perl -ple*, а
 *sed -nre* аналогично *perl -nle*. Или не очевидно? Ответьте себе честно на данный вопрос.
 Лучше не нарушать божьи заповеди и не лгать особенно самому себе, особенно если вы программист.
 В дальнейшем я также постараюсь приводить разные **perl** примеры.
 Будем учиться не просто по честному "думать на **sed**", а "думать красиво".