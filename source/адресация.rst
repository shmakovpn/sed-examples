Адресация
=========

**sed** позволяет применять команду или блок команд не ко всем строкам
(адресация по умолчанию), а к конкрентным.

И так, давайте рассмотрим все на практических примерах, для чего
используем заранее заготовленный файл **one-ten.txt**, а так же оключим
автоматический вывод **sed** с помощью ключа *-n*.

Адресацию по умолчанию мы наблюдали ранее, когда создавали самую простую
программу на **sed**. Следуя принципу: "Повторение - мать учения" и
нежелая разрывать логическую связь между тезисами данной главы, будем
предельно скучными и пройдем все по порядку.

Давайте выполним.

.. code-block:: bash

 cat one-ten.txt | sed -nre 'p'

Получили все строки из *one-ten.txt*. Следовательно, если не указывать
никакой адресации, команда или блок комманд применяется ко всем строкам.

Превратим в **perl** в самом подробнейшем виде. Для запуска следует
выполнить:

.. code-block:: bash

 cat one-ten.txt | perl -e 'ниже приведенный код'

В дальнейшем условимся, что в примерах, где приводится чисто **perl**-овый
код, запускать его следуем именно так.

.. code-block:: perl

 $hs="";
 $ps="";
 while($ps=<>) {
     chomp($ps);
     print($ps."\n");  # команда p
 }

Применим один адрес к **sed** команде.

.. code-block:: bash

 cat one-ten.txt | sed -nre '3p'

Получили только третью строчку.
На **perl** следует вопсользовать встроенной переменной
содержащий номер текущей строки стандартного ввода *$.*.

.. code-block:: perl

 $hs="";  # инициализируем hold space
 $ps="";  # инициализируем pattern space
 while($ps=<>) {  # построчно читаем *stdin* в pattern space
     chomp($ps);  # отсекаем перевод строки в конце pattern space
     # начало. собственно сам sed-скрипт
     if($.==3) {  # если идет обработка 3ей строки
         print($ps."\n");
     }
     # конец. собственно сам sed-скрипт
 }

Вспоминая, что *sed -nre 'что-то'* это *perl -nle 'что-то'* сократим написанное:

.. code-block:: bash

 cat one-ten.txt | perl -nle 'print if $.==3;'

Давайте посмотрим, как **perl** интерпретирует код приведенный выше. Выполним:

.. code-block:: bash

 perl -MO=Deparse -nle 'print if $.==3;'

И получим:

.. code-block:: perl

 BEGIN { $/ = "\n"; $\ = "\n"; }
 LINE: while (defined($_ = readline ARGV)) {
     chomp $_;
     print $_ if $. == 3;
 }
 -e syntax OK

Следующий пример показывает работу диапазона адресов.

.. code-block:: bash

 cat one-ten.txt | sed -nre '3,5p'

Будут выведены строки 3,4 и 5. Таким образом можно указать диапазон строк
от одной строки до другой включительно. Существует маленький нуанс.

.. code-block:: bash

 cat one-ten.txt | sed -nre '3,1p'

Выведет третью строку. Смысл прост. Представим наш скриптв неком  гипотетическом
виде:

.. code-block:: bash

 cat one-ten.txt | sed -nre '/условие1/,/условие2/p'

Запускать данный пример не надо, он абстрактный и работать не будет.

.. epigraph::

    Больше кода меньше слов
    И получиться любов

Давайте добавим в наш простой пример еще одну переменную.

.. code-block:: perl

 $hs='';  # hold space
 $ps='';  # pattern space
 $af=0;  # address flag
 while($ps=<>) {  # читаем стандартный ввод построчно
     chomp($ps);  # отсекаем перевод строки от pattern space
     # выполнить блок кода, если ранее было выполнено условие1
     # если условие1 не было выполнено ранее, проверить условие1,
     # запомнив результат проверки в переменную $af,
     # если результат проверки "истина" выполнить блок кода
     if($af or ($af=(условие1)) ) {
         print($ps."\n");  # выполнение команды p
         $af=0 if условие2; # сбрасываем флаг при выполнению условия 2
     }
 }

Интерпритатор **sed** сначала проверяет певое условие, второе
при этом не проверяется. При выполнении первого условия, выполняется
команда или блок команд.

Для всех последующих циклов после успешного выполнения первого условия
будет выполняться команда (блок команд) и проверяться второе условие.

Когда будет выполнено второе условие, безусловное исполнение команды (блока команд)
для последующих циклов будет отключено и возобновиться проверка первого условия.
Т.е. поведение программы вернится к режиму до выполнения условия1.

Давайте сделаем код короче:

.. code-block:: bash

 cat one-ten.txt | sed -nre '2,5p'
 # превращяется в
 cat one-ten.txt | perl -lne 'if($af or ($af=($.==2))){print;$af=0 if $.==5;}'

Вместо номеров строк можно использовать **регулярные выражения**,
так при следующей выполнении команды будут выведены строки со
второй по пятую.

.. code-block:: bash

 cat one-ten.txt | sed -nre '/tw/,5p'
 # на perl
 cat one-ten.txt | perl -lne 'if($af or ($af=(/tw/))){print;$af=0 if $.==5;}'

Еще пример (two, three, four, five)

.. code-block:: bash

 cat one-ten.txt | sed -nre '/tw/,/iv/p'
 # perl
 cat one-ten.txt | perl -lne 'if($af or ($af=(/tw/))){print;$af=0 if /iv/;}'

Адресацию можно инвертировать, указав символ *!* после адреса или диапазона
адресов.

.. code-block:: bash

 cat one-ten.txt | sed -nre '5!p'  # выведет все строки кроме пятой
 # perl
 cat one-ten.txt | perl -nle 'print if $.!=5;'

Используем *!* для исключения диапазона адресов

.. code-block:: bash

 cat one-ten.txt | sed -nre '2,9!p'  # выведет первую и последную строку
 # хотя правильнее, вырежет строки со второй по девятую включительно
 # perl
 cat one-ten.txt | perl -lne 'if($af or ($af=($.==2))){$af=0 if $.==9;}else{print;}'

Закрепим наши знания на примере с **регулярными выражениями** (1,6,7,8,9,10)

.. code-block:: bash

 cat one-ten.txt | sed -nre '/tw/,/iv/!p'
 # perl:
 cat one-ten.txt | perl -lne 'if($af or ($af=(/tw/))){$af=0 if /iv/;}else{print;}'

В случае регулярного выражения использованного в качестве второго условия,
первое условие может быть 0.

cat one-ten.txt | sed -nre '0,/o/p'
cat one-ten.txt | sed -nre '1,/o/p'
