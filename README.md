# sed-exapmles
https://www.gnu.org/software/sed/manual/sed.pdf

Comands
#######
d Удалить (PS), начать новый цикл. Perl: '$ps="", next;'
n (next) Если автоматический вывод PatternSpase не отключен (ключ -n не применен) - 
  вывести (PS) на стандартный вывод. Затем. Заменить содержимое (PS) новой строкой 
  со стандартного ввода. На языке perl: 'print $ps;exit unless defined($ps=<>);'
  Если стандартный ввод не содержит строк, sed будет завершен без выполнения остальных команд.
D Если паттерн-спэйс (PS) не содержит перевода строки (\n), запускает обычный новый цикл,
  подобно команде d. Иначе, удаляет текст в (PS) до первого (\n), и перезапускает цикл с
  полученным (PS) без чтения новой строки со стандартного ввода или файла.
  label:
      cmd1;
      cmd2;
      ...
      if $PS=~/\n/ {
          $PS=~s/^.*\n//;
          goto label:
      }
      $PS='';
      # немедленный переход к обработке следующего цикла (следующей строки стандартного ввода)

N Добавляет (\n) к (PS) и считыват следующую строку со стандартного ввода или файла в (PS).
  Если на стандартном вводе или файле нет больше строк, sed завершают свою работу без обработки
  оставшихся комманд. 
  В случае указания аргумента -z командной строки, нулевой байт (ASCII 'NUL' символ) добавляется между
  строками вместо (\n).
  По умолчанию sed не прерывает если нет следующей входной строки. Это расширение GNU которое
  может быть отключено с помощью --posix. См. стриницу 63.
  PS.="\n".<>

P Выводит на стандартный вывод или файл часть (PS) до первого (\n). $PS=~s/^(.*)\n//; print($1);

h Заменяет содержимое специального буфера hold space (HS) содержимым (PS). $HS=$PS;

H Добавляет (\n) к содержимому (HS), затем добавляет (PS) к (HS). $HS.="\n".$PS

g Заменяет содержимое (PS) на (HS). $PS=$HS

G Добавляет (\n) к (PS), а затем добавляет содержимое (HS) к (PS). $PS.="\n".$HS

x Производит обмен (swap) между (HS) и (PS). ($PS,$HS)=($HS,$PS);

Пояснения
=========

1. создам папку sed-examples
mkdir sed-examples

2. перейдем в папку sed-examples
cd sed-examples

3. инициализируем новый git репозиторий
git init

4. попробуем разобрать примеры с сайта https://www.opennet.ru/base/dev/sed1line.txt.html

5. создадим файл one-ten.txt, следующего содержания:
one
two
three
four
five
six
seven
eight
nine
ten

6. Пример "двойное пространство между строками"
cat one-ten.txt | sed G
или
cat one-ten.txt | sed -n 'G;p'
т.к. sed без -n, это sed -n 'что-то;p', где комманда p - это вывод буффера PatternSpace на стандартный вывод.
результат:
one

two

three

four

five

six

seven

eight

nine

ten

Пояснение: файл one-ten.txt выводится попадает на стандартный ввод sed, sed запускает цикл который построчно 
считывает стандартный ввод. И так программа запускается и инициализирует буффер HoldSpace пустым значением.
Буффер PatternSpace также инициализируется пустым значением. В ниже приведенном примере на perl '$hs=""; $ps="";'.
Далее запускается цикл построчной обработки содержимого потока стандартного ввода.
Вот полный аналог данной sed программы на perl.
cat one-ten.txt | perl -e '$hs=""; $ps=""; while($ps=<>){$ps.="\n".$hs; print $ps;}'
1)На первой итерации, первая строка записывается в буффер PatternSpace. В приведенном примере на perl - 
переменную $ps. Буффер HoldSpace остается пустым. Выполняется комманда G и $ps добавится "\n" и $hs. 
После чего содержимое $ps будет отправлено на стандартный вывод и мы увидим
one
пустая строка
2,3 и т.д.) Вторая, третья и последующие итерации ведут себя абсолютно аналогично первой.

7. Пример "Двойное  пространство  между  строками  исключая пустые строки"
на выходе  содержаться  не  больше  одной  пустой  строки между двумя строками с текстом
создамим еще один текстовый файл one-ten-newlines.txt
one
two

three


four



five



six





seven





eight





nine






ten








Он содержит от нуля до нескольких переводов строк между строками с текстом
Выполним команду
cat one-ten-newlines.txt | sed '/^$/d;G'
или
cat one-ten-newlines.txt | sed -n '/^$/d;G;p'
результат:
one

two

three

four

five

six

seven

eight

nine

ten

Аналог на perl:
cat one-ten-newlines.txt | perl -e '$hs=""; $ps=""; while($ps=<>){$ps="",next if $ps=~/^$/;$ps.="\n".$hs; print $ps;}'
Или более точно эмулюрующий поведение sed аналог на perl, здесь сначала при чтении строки со стандартного ввода выполняется chomp,
чтобы отрезать \n от принимаемой строки, а print что-то; заменяется на print что-то."\n".
cat one-ten-newlines.txt | perl -e '$hs=""; $ps=""; while($ps=<>){chomp $ps; $ps="",next if $ps=~/^$/;$ps.="\n".$hs; print $ps."\n";}'
Вместо print что-то."\n"; можно оставить print что-то, но тогда perl необходимо запускать с ключом -l
cat one-ten-newlines.txt | perl -le '$hs=""; $ps=""; while($ps=<>){chomp $ps; $ps="",next if $ps=~/^$/;$ps.="\n".$hs; print $ps;}'

Все тоже самое, как и в предыдущем примере, но сначала будет выполнена команда d для пустых строк,
пустые строки определяются регурярным выражением /^$/, которое находит строки у которых после начало сразу идет конец.
Для пустых строк выполняется команда d. Которая удалит все содержимое PatternSpace, прервет итерацию обработки текущей
строки и перейдет к обработке следующей.
Что на языке perl можно выразить как '$ps="",next if $ps=~/^$/;'

8. Пример "тройное пространство между строками"
Выполним команду
cat one-ten.txt | sed 'G;G'
или
cat one-ten.txt | sed -n 'G;G;p'
вывод:
one


two


three


four


five


six


seven


eight


nine


ten


На perl это будет:
cat one-ten.txt | perl -e '$hs=""; $ps=""; while($ps=<>){$ps.="\n".$hs; $ps.="\n".$hs; print $ps;}'
или в более точной эмуляции
cat one-ten.txt | perl -le '$hs=""; $ps=""; while($ps=<>){chomp $ps; $ps.="\n".$hs; $ps.="\n".$hs; print $ps;}'

Как было сказано ранее, команда G в sed это '$ps.="\n".$hs;' в perl. Т.е. к PatternSpace будет два
раза добавлено "\n" плюс "ничего".

9. Пример "удалить каждую вторую строку"
Команда
cat one-ten.txt | sed 'n;d'
или
cat one-ten.txt | sed -n 'p;n;d'
Вывод:
one
three
five
seven
nine
На perl: 
cat one-ten.txt | perl -e '$hs=""; $ps=""; while($ps=<>){print $ps; exit unless defined($ps=<>); $ps="", next; }'
или
cat one-ten.txt | perl -le '$hs=""; $ps=""; while($ps=<>){chomp $ps; print $ps; exit unless defined($ps=<>); chomp $ps; $ps="", next; }'

Читается строка "one\n", выводится на стандартный вывод. Далее в $ps читается вторая строка со стандартного ввода. 
Потом отрабатывает команда d: PatternSpace очищается и начинася новый цикл.
На втором цикле читается следующая строка со стандартного ввода (третья строка), она выводится на стандартный вывод.
Читается четвертая строка, очищается $ps, переход на новый цикл.
... и т.д.
Читается девятая строка, выводся на стандартный вывод.
Читается десятая строка (т.к. на стандартный ввод передано десять строк). Очищается $ps. Переход на новый цикл.
Программа завершается т.к. не строк в потоке стандартного ввода.
Создадим файл one-nine.txt из девяти строк.
Тогда последний цикл изменится на:
Читается девятая строка, выводся на стандартный вывод.
Происходит выход из программы по условию невозможности чтения со стандартного ввода 'exit unless defined($ps=<>);'

10. Пример "Вставить   пустую  строку  перед  каждой  строкой  соответствующей регулярному выражению /regex/"
Выполним комадну
cat one-nine.txt | sed '/one\|six/{x;p;x;}'
или
cat one-nine.txt | sed -n '{/one\|six/{x;p;x;}};{p}'
результат:

one
two
three
four
five

six
seven
eight
nine
Для первой строки т.к. она соответствует регулярному выражению /one|six/ выполнится последовательность команд:
Первая строка со стандартного ввода считывается в переменную $ps, а в $hs тем временем находится пустое значение.
Происходит своп $ps и $hs. Далее $ps выводится на стандартный вывод. Т.е. пустая строка.
Снова происходит своп. И $ps теперь содержит свое первоначальное значение.
Далее выполнится следующий блок кода и $ps (которое снова содержит значение первой строки) отправится на стандартный вывод.
Наступит цикл обработки второйстроки. Т.к. она не соответствует регулярному выражению. Выполнится только второй блок кода.
И вторая строка будет выведена на стандартный вывод как есть.
Аналогичные второй строке циклы выполнятся для третьей, четвертой, пятой, седьмой и всех последующих строк.
Шестая строка повторит судьбу первой и перед ней на стандартный ввод будет выведена пустая строка.
perl:
cat one-nine.txt | perl -e '$hs="\n"; $ps=""; while($ps=<>){if($ps=~/one|six/){($hs,$ps)=($ps,$hs);print $ps;($hs,$ps)=($ps,$hs);}; print $ps; }'
или
cat one-nine.txt | perl -e '$hs=""; $ps=""; while($ps=<>){chomp $ps; if($ps=~/one|six/){($hs,$ps)=($ps,$hs);print $ps."\n";($hs,$ps)=($ps,$hs);}; print $ps."\n"; }'
второй вариант perl длиннее, однако, он точнее эмулирует поведение sed. 
можно сделать лучше
cat one-nine.txt | perl -le '$hs=""; $ps=""; while($ps=<>){chomp $ps; if($ps=~/one|six/){($hs,$ps)=($ps,$hs);print $ps;($hs,$ps)=($ps,$hs);}; print $ps; }'

11. Привет "Вставить   пустую   строку  после  каждой  строки  соответствующей регулярному выражению /one|six/"
cat one-ten.txt | sed '/one\|six/G'
или
cat one-ten.txt | sed -n '/one\|six/G;p'
или
cat one-ten.txt | perl -le '$hs=""; $ps=""; while($ps=<>){chomp $ps; $ps.="\n".$hs if $ps=~/(one|six)/; print $ps;}'
Для строк соответствующих шаблону к PatterSpace добавится \n

12. Пример "Вставить пустую строку перед и после каждой строки соответствующей регулярному выражению /one|six/"
cat one-ten.txt | sed '/one\|six/{x;p;x;G;}'
или
cat one-ten.txt | sed -n '/one\|six/{x;p;x;G;};{p}'
или
cat one-ten.txt | perl -le '$hs=""; $ps=""; while($ps=<>){chomp $ps; if($ps=~/(one|six)/){($ps,$hs)=($hs,$ps); print $ps; ($ps,$hs)=($hs,$ps); $ps.="\n".$hs;}; print $ps;}'
вывод:

one

two
three
four
five

six

seven
eight
nine
ten
Очевидно однострочники на sed будут покороче чем на perl! 
Данный пример не так уж прост, как это может показаться. Первое, что необходимо отметить, работа команды p.
Команда p выводить PatternSpace на стандартный вывод и добавляет символ перевода строки.
В perl это можно выразить так: print '$ps."\n";'. Если в PatternSpace находится пустое значение, будет выведена пустая строка и 
следующий вызов p будет выводить данные уже в новой строке.
Второй момент, при чтении стандартного ввода в PatternSpace производится удаление символа перевода строки.
В perl данный фукционал реализуется за счет вызова команды 'chomp $ps;', которая должна выполняться
сразу же после любого чтения со стандартного ввода '$ps=<>'. Если бы chompa не было. То на стандартном выводе 
появлялись бы лишние пустые строки. Т.к. команда p добавляет перевод строки.

Теперь собственно к примеру.
При обработки первой строки "one\n" она попадает в PatternSpace или $ps, при от нее в конце отсекается "\n".
Получаем $ps=="one". Т.к. "one" соответствует регулярному выражению /(one|six)/ обработка отправляется в блок команд {x;p;x;G;}.
Команда x (perl: '($ps,$hs)=($hs,$ps);') поместит в PatternSpace пустую строку из HoldSpace, а строку "one" сохранит в HoldSpace.
Команда p отправит на стандартный вывод '""."\n"' т.е. вставит пустую строку и перейдет на следующую.
Команда x выполнит обратный обмен межу PatternSpace и HoldSpace, таким образом в HoldSpace - пустая строка. А в PatternSpace
вернется "one".
Команда G добавит в PatternSpace перевод строки и пустую строку из HoldSpace. '$ps.="\n".$hs;'. Теперь $ps=="one\n".
Затем выполнится блок из одной команды {p}. И на стандартный вывод уйдут две строки one и пустая, что соответствует "one\n\n". 
Цикл обработки первой строки закончится и начнется цикл обработки второй.
Вторая строка не соответствует регулярному выражению, следовательно выполнится только блок {p}.
И программа перейдет к обработке третьей строки.
Строки 3,4,5,7,8 и т.д. будут обработаны так же как и строка 2 потока стандартного ввода.
Строка 6 сопадает с регулярным выражением и обработается подобно строке 2.

13. Пример "перевернуть последовательность строк (эмуляция "tac")
cat one-ten.txt | sed '1!G;h;$!d'
или
cat one-ten.txt | sed -n '1!G;h;$!d;p'
на perl:
cat one-ten.txt | perl -le '$ps=""; $hs=""; while($ps=<>){chomp $ps; $ps.="\n".$hs if $.!=1; $hs=$ps; $ps="",next unless eof; print $ps;}'
есть еще вариант, в котором изначально автоматический вывод PatternSpace на стандартный вывод отключен и 
на стандартный вывод выводится только последняя строка. В предыдущих вариантах, все строки кроме последней удаляются из PatternSpace,
и все оставшиеся строки отправляются на стандартный вывод.
Не знаю, что лучше печатать последнего или печатать всех, но перед этим удалить всех кроме последнего.
cat one-ten.txt | sed -n '1!G;h;$p'
На perl это будет:
cat one-ten.txt | perl -le '$ps=""; $hs=""; while($ps=<>){chomp $ps; $ps.="\n".$hs if $.!=1; $hs=$ps; print $ps if eof;}'
Пояснение:
Первая строка читается в $ps, от нее отрезается в конце \n. Получаем в $ps=="one"
Команда 1!G (perl: '$ps.="\n".$hs if $.!=1;') для первой строки пропускается
Команда h (perl: '$hs=$ps;'). Получаем $ps=="one" и $hs=="one"
Команда $!d (perl: '$ps="",next unless eof;'). Удалит все из $ps и перейдет на следующий цикл
Команда p на данной итерации не выполнится, т.к. $!d запустила безусловный переход на цикл обработки следующей строки
Цикл обработки строки 2 
Вторая строка читается в $ps, от не отрезается в конце \n. Получаем в $ps=="two"
Команда 1!G (perl: '$ps.="\n".$hs if $.!=1;') добавит к $ps перевод строки и содержимое $hs которое "one". И в $ps=="two\none".
Команда h (perl: '$hs=$ps;'). Получаем $ps=="two\none" и $hs=="two\none"
Команда $!d (perl: '$ps="",next unless eof;'). Удалит все из $ps и перейдет на следующий цикл
Команда p на данной итерации не выполнится, т.к. $!d запустила безусловный переход на цикл обработки следующей строки
Цикл обработки строки 3
Третья строка читается в $ps, от не отрезается в конце \n. Получаем в $ps=="three"
Команда 1!G (perl: '$ps.="\n".$hs if $.!=1;') добавит к $ps перевод строки и содержимое $hs которое "two\none". И в $ps=="three\ntwo\none".
...
Цикл обработки последней строки
Последняя строка читается в $ps, от не отрезается в конце \n. Получаем в $ps=="ten"
Команда 1!G (perl: '$ps.="\n".$hs if $.!=1;') добавит к $ps перевод строки и содержимое $hs которое "nine\n...\none". И в $ps=="ten\nnine\n...\none".
Команда h (perl: '$hs=$ps;'). Получаем $ps=="ten\n..\none" и $hs=="ten\n..\none"
Команда $!d (perl: '$ps="",next unless eof;'). Пропускается.
Команда p. Выведет $ps=="ten\n..\none" на стандартный вывод.
После чего sed завершается.

14. Пример "Перевернуть каждую строку в файле задом наперед (эмуляция "rev")"
cat one-ten.txt | sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//'
или
cat one-ten.txt | sed -n '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//;p'
на perl
TODO
cat one-ten.txt | perl -le '$ps=""; $hs=""; while($ps=<>){chomp $ps; start: $ps.="\n".$hs if $ps!~/\n/; $ps=~s/(.)(.*\n)/$&$2$1/; print $ps; }'









